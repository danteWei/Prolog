% Xinjing Wei
% CSCI 3136 - Problem 4 - Interpreter Grammar File

% In order to allow for easier interpreting later, we must use a definite clause grammar with arguments.
% Arguments in DCGs are used to build content lists from the base case up. Recall that DCGs are written
% in the following form:
%
%       head(Arguments) --> ['terminal'], non_terminal(Arguments).
%
% In this form we can see that, similarly to the typical Prolog predicate form, grammars are also capable
% of utilizing variables in a recursive fashion. In the above example, the value generated by non_terminal
% is called Arguments and is used as the value generated by head. The output of head will be some list of
% forms which were constructed from the terminal productions in the grammar and built upward.
%
% We can retrieve the created list using the following query:
%
%       phrase( head(CreatedList), InputTokens, [] ).
%
% This query sends a list of input tokens to the head production in the grammar and produces a list
% called CreatedList if parsing is successful.
%
% The predicate phrase/3 is a built-in predicate which takes three arguments. The first is a reference to
% the grammar production we would like to use, which contains a single argument describing the grammar's output.
% The second argument is the list of tokens to be parsed by the language. The final argument is a list containing
% whatever tokens should be left over after the parsing is completed. For more information, check SWI-Prolog's
% database for phrase/2 and phrase/3.
%
% Once you have an LL(1) grammar, you should parse it normally as you did in the previous assignment. If your
% grammar is LL(1) there will be no need for Prolog to backtrack to find alternative options in the grammar
% as every production will be unambiguous. This means that rather than having many repeated (and messy)
% tokens written to the screen, Prolog will print the code structure almost exactly as it is found.
%
% Once you finish your basic LL(1) grammar, you will have to decide on a form to be accepted by the interpreter
% in order to facilitate recursive calculations.
%
% I recommend you design your grammar in the following manner:
%
% Since the language uses recursion to solve sub-problems, we should attempt to solve all the sub-problems
% first. For example, if you have an expression which is Exp -> Value ArithmeticOperator Value, you can also
% imagine writing this in the list form:
%
%       [Value ArithmeticOperator Value]
%
% Once you see this expression as a list, you can also see that both Value and ArithmeticOperator may also be
% put into list form:
%
%       [[number] [+] [identifier]]
%
% If you arrive at this final form, and these tokens can be replaced with the original tokens from the input
% (as in, number could be 3 and identifier could be 'input', which might resolve to 5), then we can easily
% easily write a simple predicate that will always be capable of calculating the result of this expression,
% assuming we also have predicates for finding the results of the non-terminals inside. For instance, if we
% want to properly handle the case of addition:
%
%       expression( [Value1, '+', Value2], Result ) :-
%             value( Value1, Value1Result ),
%             value( Value2, Value2Result ),
%             Result is Value1Result + Value2Result.
%
% We can see that as long as the value predicate can give us a numerical result for Value1 and Value2, we can
% easily calculate the result for the expression.
%
% By applying this logic to each relevant production in your language, you can create an output structure for
% your grammar which easily maps to a set of predicates in your interpreter. By processing these predicates in
% the correct order you will be able to recursively calculate each production, thus fully executing your code.
%

% Consult the lexer.
:- consult('lexer.pl').

% Our grammar is defined as one which is capable of parsing a set of valid sentences based on the following grammar rules.
%
%	Program      -> FunctionList
%
%	FunctionList -> Function FL
%	FL           -> FunctionList|ε
%
%	Function     -> TypeID ( TypeIDList ) = Expression
%
%	TypeID       -> int id
%	TypeID       -> bool id
%
%	TypeIDList   -> TypeID TL
%	TL           -> , TypeIDList|ε
%
%	Expression   -> if Comparison then Value else Value
%	Expression   -> let id = Value in Expression
%	Expression   -> Value VL
%	VL           -> Arithmetic Value|ε
%
%	Arithmetic   -> +
%	Arithmetic   -> -
%
%   Comparison   -> Value Logic Value
%   Logic        -> ==|!=|>|>=
%
%   Value        -> number
%   Value        -> id DL
%   DL           -> ( Parameters )|ε
%
%   Parameters   -> Value PR
%   PR           -> , Parameters|ε
%

program(Result) --> functionList(Result).

functionList(Result) --> function(Function), functionList(FunctionList), { Result = [Function, FunctionList] }.
functionList([]) --> [].

function(Result) --> typeID(TypeID), open_p(OPEN_P), typeIDList(TypeIDList), close_p(CLOSE_P), assign(ASSIGN), expression(Expression), { Result = [TypeID, OPEN_P, TypeIDList, CLOSE_P, ASSIGN, Expression] }.

typeID(Result) --> type(Type), id(IDENTIFIER), { Result = [Type, IDENTIFIER] }.

typeIDList(Result) --> typeID(TypeID), comma(COMMA), typeIDList(TypeIDList), { Result = [TypeID, COMMA, TypeIDList] }.
typeIDList([Result]) --> typeID(Result).

expression(Result) --> cond_if(COND_IF), comparison(Comparison), cond_then(COND_THEN), value(Value1), cond_else(COND_ELSE), value(Value2), { Result = [COND_IF, Comparison, COND_THEN, Value1, COND_ELSE, Value2] }.
expression(Result) --> let(LET), id(IDENTIFIER), assign(ASSIGN), value(Value), let_in(LET_IN), expression(Expression), { Result = [LET, IDENTIFIER, ASSIGN, Value, LET_IN, Expression] }.
expression(Result) --> value(Value1), arithmetic(Arithmetic), value(Value2), { Result = [Value1, Arithmetic, Value2] }.
expression(Result) --> value(Result).

comparison(Result) --> value(Value1), logic_op(Logic), value(Value2), { Result = [Value1, Logic, Value2] }.

value(Result) --> number(Result).
value(Result) --> id(Result).
value(Result) --> id(IDENTIFIER), open_p(OPEN_P), parameters(Parameters), close_p(CLOSE_P), { Result = [IDENTIFIER, OPEN_P, Parameters, CLOSE_P] }.

parameters(Result) --> value(Value), comma(COMMA), parameters(Parameters), { Result = [Value, COMMA, Parameters] }.
parameters([Result]) --> value(Result).

open_p('(') --> ['('].
close_p(')') --> [')'].

type('int') --> ['int'].
type('bool') --> ['bool'].

assign('=') --> ['='].
comma(',') --> [','].

cond_if('if') --> ['if'].
cond_then('then') --> ['then'].
cond_else('else') --> ['else'].

let('let') --> ['let'].
let_in('in') --> ['in'].

arithmetic('+') --> ['+'].
arithmetic('-') --> ['-'].

logic_op('==') --> ['=='].
logic_op('!=') --> ['!='].
logic_op('>') --> ['>'].
logic_op('>=') --> ['>='].

number(INTEGER) --> [N], { atom_number(N, INTEGER), integer(INTEGER) }.
id(IDENTIFIER) --> [IDENTIFIER].
